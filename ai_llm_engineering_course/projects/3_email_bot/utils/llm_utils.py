import re
import json 

class LLMUtils:
    def clean_json_string(self, json_str):
        """
        Cleans common JSON syntax errors that may be generated by the LLM.
        
        Args:
            json_str (str): Potentially malformed JSON string
            
        Returns:
            str: Corrected JSON string
        """
        if not json_str:
            return json_str
            
        # Replace semicolons with commas at the end of values
        json_str = re.sub(r'";(\s*})', '"\1', json_str)
        json_str = re.sub(r'";(\s*,)', '",\1', json_str)
        
        # Replace extra commas at the end of objects
        json_str = re.sub(r',(\s*})', r'\1', json_str)
        
        # Replace single quotes with double quotes
        json_str = re.sub(r"'([^']*)'", r'"\1"', json_str)
        
        # Fix keys without quotes
        json_str = re.sub(r'([{,]\s*)([a-zA-Z0-9_]+)(\s*:)', r'\1"\2"\3', json_str)
        
        # Replace all semicolons with commas
        json_str = json_str.replace(";", ",")
        
        return json_str
        
    def robust_json_parse(self, text):
        """
        Attempts to parse JSON robustly, handling various types of common errors.
        
        Args:
            text (str): Text containing potentially malformed JSON
            
        Returns:
            dict or list: The parsed JSON object
            
        Raises:
            ValueError: If the JSON cannot be parsed
        """
        # First, try to extract JSON from the response
        try:
            json_text = self.extract_json_from_response(text)
        except ValueError:
            # If extraction fails, use the complete text
            json_text = text
            
        # Clean the JSON
        clean_json = self.clean_json_string(json_text)
        
        # Try to parse the cleaned JSON
        try:
            return json.loads(clean_json)
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON after initial cleaning: {e}")
            print(f"Error position: line {e.lineno}, column {e.colno}, char {e.pos}")
            
            # Try more aggressive cleaning
            clean_json = clean_json.replace(";", ",")
            
            # Try to fix problems with quotes
            clean_json = re.sub(r'([^\\])(")(.*?)([^\\])(")(\s*:)', r'\1\2\3\4\5\6', clean_json)
            
            # Try to fix problems with commas
            clean_json = re.sub(r'(}|"])\s*(}|])', r'\1,\2', clean_json)
            
            try:
                return json.loads(clean_json)
            except json.JSONDecodeError as e2:
                print(f"Error parsing JSON after aggressive cleaning: {e2}")
                print(f"Error position: line {e2.lineno}, column {e2.colno}, char {e2.pos}")
                
                # Try to manually extract JSON objects
                try:
                    return self.manual_json_extraction(json_text)
                except Exception as e3:
                    print(f"Manual extraction failed: {e3}")
                    raise ValueError(f"Could not parse JSON: {e2}")
                    
    def manual_json_extraction(self, text):
        """
        Attempts to manually extract JSON objects from text.
        
        Args:
            text (str): Text containing potentially malformed JSON
            
        Returns:
            list: List of extracted JSON objects
            
        Raises:
            ValueError: If JSON objects cannot be extracted
        """
        # Look for JSON object patterns
        objects = []
        
        # Pattern to find JSON objects
        pattern = r'{[^{}]*"message_id"[^{}]*"from"[^{}]*"subject"[^{}]*"problem"[^{}]*"solution"[^{}]*}'
        matches = re.finditer(pattern, text, re.DOTALL)
        
        for match in matches:
            obj_text = match.group(0)
            # Clean the object
            obj_text = self.clean_json_string(obj_text)
            # Replace semicolons with commas
            obj_text = obj_text.replace(";", ",")
            
            try:
                obj = json.loads(obj_text)
                objects.append(obj)
            except json.JSONDecodeError:
                print(f"Could not parse object: {obj_text[:100]}...")
        
        if not objects:
            raise ValueError("Could not extract JSON objects")
            
        return objects
        
    def fix_json_at_position(self, json_str, error_line, error_col):
        """
        Attempts to fix a JSON at a specific position where an error occurred.
        
        Args:
            json_str (str): JSON string with error
            error_line (int): Line where the error occurred
            error_col (int): Column where the error occurred
            
        Returns:
            str: Corrected JSON
        """
        lines = json_str.split('\n')
        
        # Check if the error line is within bounds
        if error_line <= 0 or error_line > len(lines):
            return json_str
            
        # Adjust for zero-based index
        line_idx = error_line - 1
        problematic_line = lines[line_idx]
        
        print(f"Problematic line ({error_line}): {problematic_line}")
        
        # If the error is near the end of the line, it might be a semicolon
        if error_col > 0 and error_col <= len(problematic_line):
            # Check characters near the error position
            start_pos = max(0, error_col - 10)
            end_pos = min(len(problematic_line), error_col + 10)
            context = problematic_line[start_pos:end_pos]
            print(f"Error context: ...{context}...")
            
            # Try to identify and fix common problems
            
            # 1. Replace semicolon with comma
            if error_col < len(problematic_line) and problematic_line[error_col-1] == ';':
                fixed_line = problematic_line[:error_col-1] + ',' + problematic_line[error_col:]
                lines[line_idx] = fixed_line
                print(f"Replaced ';' with ',' at position {error_col}")
            
            # 2. Add missing comma after double quotes followed by space and double quotes
            elif re.search(r'"(\s*)"', problematic_line[error_col-5:error_col+5]):
                fixed_line = problematic_line[:error_col] + ',' + problematic_line[error_col:]
                lines[line_idx] = fixed_line
                print(f"Added missing comma at position {error_col}")
                
            # 3. Fix single quotes to double quotes
            elif "'" in problematic_line[error_col-5:error_col+5]:
                fixed_line = problematic_line.replace("'", '"')
                lines[line_idx] = fixed_line
                print(f"Replaced single quotes with double quotes on line {error_line}")
                
            # 4. Remove invalid characters
            else:
                # Remove non-ASCII and control characters
                fixed_line = ''.join(c if (c.isascii() and c.isprintable()) or c in ['\n', '\t', ' '] else '' for c in problematic_line)
                # Replace any suspicious character with a comma if it's between quotes and braces/brackets
                fixed_line = re.sub(r'"(\s*[^\s,\{\}\[\]"\']+\s*)["\{\}\[\]]', r'",\2', fixed_line)
                lines[line_idx] = fixed_line
                print(f"Removed invalid characters on line {error_line}")
        
        # Rebuild the JSON
        return '\n'.join(lines)
        
    def emergency_json_fix(self, json_str):
        """
        Emergency method to try to fix severely corrupted JSON.
        
        Args:
            json_str (str): JSON string with error
            
        Returns:
            list: List of extracted JSON objects or empty list if it fails
        """
        try:
            # Check if it's a JSON array
            if json_str.strip().startswith('[') and json_str.strip().endswith(']'):
                # Extract individual objects
                objects_text = re.findall(r'{[^{}]*}', json_str)
                
                results = []
                for obj_text in objects_text:
                    # Clean the object
                    clean_obj = self.clean_json_string(obj_text)
                    
                    # Ensure all keys are in double quotes
                    clean_obj = re.sub(r'([{,]\s*)([a-zA-Z0-9_]+)(\s*:)', r'\1"\2"\3', clean_obj)
                    
                    # Replace single quotes with double quotes in values
                    clean_obj = re.sub(r':\s*\'([^\']*)\'', r':"\1"', clean_obj)
                    
                    # Remove extra commas before closing braces
                    clean_obj = re.sub(r',\s*}', '}', clean_obj)
                    
                    # Try to parse the object
                    try:
                        obj = json.loads(clean_obj)
                        
                        # Check if it has the required fields
                        required_fields = ["message_id", "from", "subject", "solution"]
                        if all(field in obj for field in required_fields):
                            results.append(obj)
                    except json.JSONDecodeError:
                        # Ignore objects that cannot be parsed
                        pass
                
                if results:
                    print(f"Emergency extraction successful! Found {len(results)} valid objects.")
                    return results
            
            # If it's not an array or no valid objects are found
            raise ValueError("Could not extract valid JSON objects")
            
        except Exception as e:
            print(f"Emergency extraction failed: {e}")
            return []
            
    def manual_json_construction(self, text):
        """
        Manually constructs JSON objects from unstructured text.
        Useful for cases where the JSON is severely corrupted.
        
        Args:
            text (str): Text containing information that can be converted to JSON
            
        Returns:
            list: List of constructed JSON objects or empty list if it fails
        """
        try:
            # For seeder_incidents.py - look for title and description patterns
            if "title" in text and "description" in text:
                # Look for patterns that appear to be titles
                title_matches = re.findall(r'"title"\s*:\s*"([^"]+)"', text)
                desc_matches = re.findall(r'"description"\s*:\s*"([^"]+)"', text)
                
                # If we found titles and descriptions
                if title_matches and desc_matches:
                    # Manually build JSON objects
                    results = []
                    for i in range(min(len(title_matches), len(desc_matches))):
                        obj = {
                            "title": title_matches[i],
                            "description": desc_matches[i]
                        }
                        results.append(obj)
                    
                    if results:
                        print(f"Manual construction successful! Found {len(results)} objects.")
                        return results
            
            # For seeder_reply.py - look for message_id, from, subject patterns, etc.
            elif "message_id" in text and "from" in text and "subject" in text:
                # Look for patterns that appear to be message_ids
                msgid_matches = re.findall(r'"message_id"\s*:\s*"([^"]+)"', text)
                from_matches = re.findall(r'"from"\s*:\s*"([^"]+)"', text)
                subject_matches = re.findall(r'"subject"\s*:\s*"([^"]+)"', text)
                solution_matches = re.findall(r'"solution"\s*:\s*"([^"]+)"', text)
                
                # If we found the necessary fields
                if msgid_matches and from_matches and subject_matches and solution_matches:
                    # Manually build JSON objects
                    results = []
                    for i in range(min(len(msgid_matches), len(from_matches), len(subject_matches), len(solution_matches))):
                        obj = {
                            "message_id": msgid_matches[i],
                            "from": from_matches[i],
                            "subject": subject_matches[i],
                            "solution": solution_matches[i]
                        }
                        results.append(obj)
                    
                    if results:
                        print(f"Manual construction successful! Found {len(results)} objects.")
                        return results
            
            # If we couldn't build JSON objects
            return []
            
        except Exception as e:
            print(f"Manual construction failed: {e}")
            return []
    def extract_json(self, text):
        start = text.find("[")
        end = text.rfind("]") + 1
        if start != -1 and end != -1:
            return text[start:end]
        return text

    def is_valid_json(self, text):
        try:
            json.loads(text)
            return True
        except json.JSONDecodeError:
            return False

    def extract_json_from_response(self, text):
        # Remove markdown code blocks (```json ... ```)
        code_blocks = re.findall(r"```(?:json)?(.*?)```", text, re.DOTALL)
        if code_blocks:
            return code_blocks[0].strip()
        
        # If there are no markdown blocks, try to find JSON array directly
        match = re.search(r"\[.*\]", text, re.DOTALL)
        if match:
            return match.group(0).strip()
        
        raise ValueError("No JSON found in the model response.")
